---
title: 'Data Structures'
description: 'Learn how data is stored and processed in Runchat'
---

Runchat works with several data structures to make it simple to perform different operations without writing code. 
These are **items**, **lists**, **objects** and **data trees**. Under the hood, all data in Runchat is stored in a data tree, though you won't 
typically need to manipulate this structure unless you want to perform complex data matching operations.

## Items

Items are data with a single value. When you enter data directly into input forms on a node, you are setting a single value per parameter.

## Lists (arrays)

Lists are data with more than one value. You can create a list of values using the `+` button on the input node, generating lists of data with the `array` output format on the prompt node, processing lists of data using javascript or retrieving lists from an API. 

## Objects (JSON)

Objects are a special data type used to describe *things* using key-value pairs. Runchat uses JSON (Javascript object notation) to describe objects. 
Objects are commonly used to format data to make requests to APIs (including prompting language models). Objects can have properties that are lists of data. 

## Data Trees

Data Trees are objects with some specific constraints.
Key-value pairs in the object are called branches. 
Keys are called "paths" and are used to address some data in the tree. 
Values for each branch are always an array (list) of data. 

### Data Tree path notation

Runchat uses a specific format to describe paths in a data tree. 
This format is `A:B:...N` where A and B represent the index of the parent item that produced the data.  
All node data is stored on path "0" until it is manipulated. The "0" path represents the "trunk" of the tree. 
If we applied an operation to our data that generated a new list of values for each value in our tree, we might expect our paths to look something like "0:0, "0:1". "0:2" etc, with each branch pointing to a list of values generated by that operation on that item.

# Why do we need data trees

Runchat stores all parameter inputs and outputs in Data Trees. 

We use data trees for four reasons. 
1. Simplify matching data from multiple parameters: We can use paths in one data tree to find matching data in another tree.
2. Implement matching heuristics: We can use paths to fallback to parent data when an exact match is not found
3. Unified format: We can use data trees to describe single items, lists of items, and arbitrarily nested data
4. Tracing: When a node operates on a data tree we can modify path structures to easily trace where that data came from. 
5. Future proofing: Data trees allow for very complex data matching operations that may be required for future use cases.
